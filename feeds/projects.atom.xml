<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>@fibasile</title><link href="http://fibasile.github.io/" rel="alternate"></link><link href="http://fibasile.github.io/feeds/projects.atom.xml" rel="self"></link><id>http://fibasile.github.io/</id><updated>2014-12-01T10:12:00+01:00</updated><entry><title>Node.js binary packages</title><link href="http://fibasile.github.io/new-node-modules.html" rel="alternate"></link><updated>2014-12-01T10:12:00+01:00</updated><author><name>Fiore Basile</name></author><id>tag:fibasile.github.io,2014-12-01:new-node-modules.html</id><summary type="html">&lt;p&gt;As you might have experienced compiling node.js for the Yun is not very easy.&lt;/p&gt;
&lt;p&gt;For this reason I provide a binary package you can just copy on your Yun and run directly.   &lt;/p&gt;
&lt;p&gt;Some of you also requested me to provide few modules already compiled.&lt;/p&gt;
&lt;p&gt;Here's the list of available packages and modules in my Yun packages repository:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Barebone Node.js v0.10.20 &lt;a href="https://raw.github.com/fibasile/yun-packages/master/node-v0.10.20-mips.tgz"&gt;node-v0.10.20-mips.tgz&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Npm &lt;a href="https://raw.github.com/fibasile/yun-packages/master/npm-mips.tgz"&gt;npm-mips.tgz&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Serial &lt;a href="https://raw.github.com/fibasile/yun-packages/master/serial-mips.tgz"&gt;serial-mips.tgz&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ws &lt;a href="https://raw.github.com/fibasile/yun-packages/master/ws-mips.tgz"&gt;ws-mips.tgz&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;johnny-five &lt;a href="https://raw.github.com/fibasile/yun-packages/master/johnny-five-mips.tgz"&gt;johnny-five-mips.tgz&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you have problems with this packages, of feel the need for others you can contact me and I'll do my best to help.&lt;/p&gt;</summary><category term="node"></category><category term="yun"></category><category term="arduino"></category><category term="modules"></category></entry><entry><title>Send accelerometer data via BLE to OSC Server</title><link href="http://fibasile.github.io/ble-to-osc.html" rel="alternate"></link><updated>2013-12-01T18:12:00+01:00</updated><author><name>Fiore Basile</name></author><id>tag:fibasile.github.io,2013-12-01:ble-to-osc.html</id><summary type="html">&lt;p&gt;I built this sample Mac app to report accelerometer data acquired from Adafruit Flora, sent using BLE to the Mac and then converted in OSC format, for example to be forwarded to Osculator or similar apps.&lt;/p&gt;
&lt;h2&gt;Source code&lt;/h2&gt;
&lt;p&gt;You can find the source code at the following repository:&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/fibasile/BLE_to_OSC"&gt;https://github.com/fibasile/BLE_to_OSC&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Required hardware&lt;/h2&gt;
&lt;p&gt;The demo app was tested with the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Adafruit Flora&lt;/li&gt;
&lt;li&gt;Adafruit LSM303 Accelerometer &lt;/li&gt;
&lt;li&gt;RedBear Lab BLE Mini&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Connect the LSM303 accelerometer to Flora SDL and SCL, 3.3v and GND pins.&lt;/p&gt;
&lt;p&gt;Connect the BLE mini TX to Flora RX and RX to Flora TX, 3.3v and GND pins.  &lt;/p&gt;
&lt;p&gt;Add a Lipo battery or plug in the USB cable to the Flora.&lt;/p&gt;
&lt;h2&gt;Required software&lt;/h2&gt;
&lt;p&gt;Make sure you checkout the repository using the recursive option, so you also get the submodules containing all the required dependencies into the deps folder.&lt;/p&gt;
&lt;h2&gt;Instructions&lt;/h2&gt;
&lt;p&gt;Make sure you have installed the Adafruit_LSM303 library in your Arduino Library folder.&lt;/p&gt;
&lt;p&gt;Open the Adafruit Arduino IDE version, and load the FloraAccel.ino sketch you find in the folder.&lt;/p&gt;
&lt;p&gt;This sketch uses the Firmata protocol, sending SYSEX messages containing the readings from the accelerometer. The only thing which is custom is that since accelerometer produces signed integers, those are sent as two bytes instead of one per axis.&lt;/p&gt;
&lt;p&gt;Now compile the Mac project BleToOSC using XCode and run it.&lt;/p&gt;
&lt;h2&gt;Screenshots&lt;/h2&gt;
&lt;p&gt;&lt;img alt="BLE Sensor" src="images/ble-to-osc/bleosc1.png" /&gt;
&lt;img alt="OSC Server" src="images/ble-to-osc/bleosc2.png" /&gt;&lt;/p&gt;
&lt;p&gt;You can configure:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;In the BLE Sensor tab: the kind of bluetooth low energy modem, currently only Ble Mini is supported, but a Xadow version will be added soon. &lt;/li&gt;
&lt;li&gt;In the OSC Server tab: the OSC server host and port number, and also the path that will show up in OSC server. The example uses a naming similar to what you might use for a Nintendo Wii Nunchuck controller.&lt;/li&gt;
&lt;/ul&gt;</summary><category term="objc"></category><category term="firmata"></category><category term="flora"></category><category term="mac"></category><category term="arduino"></category></entry><entry><title>Xadow Dashboard</title><link href="http://fibasile.github.io/xadow-dashboard.html" rel="alternate"></link><updated>2013-11-10T18:12:00+01:00</updated><author><name>Fiore Basile</name></author><id>tag:fibasile.github.io,2013-11-10:xadow-dashboard.html</id><summary type="html">&lt;h2&gt;Introducing Xadow&lt;/h2&gt;
&lt;p&gt;The Xadow platform from SeeedStudio is a great starting point for any wearable project. Since its release I've been very interested in using it
because of its form factor (really tiny stuff) and Arduino compatibility.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Xadow Dashboard" src="images/xadow-dashboard/xadow.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;The Xadow modular design allows to combine several modules with the main Xadow mainboard, including:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;OLED Display&lt;/li&gt;
&lt;li&gt;LED Matrix.&lt;/li&gt;
&lt;li&gt;Accelerometer&lt;/li&gt;
&lt;li&gt;Barometer&lt;/li&gt;
&lt;li&gt;BLE radio&lt;/li&gt;
&lt;li&gt;GPS&lt;/li&gt;
&lt;li&gt;EEPROM memory&lt;/li&gt;
&lt;li&gt;Motor&lt;/li&gt;
&lt;li&gt;NFC&lt;/li&gt;
&lt;li&gt;Groove adapter&lt;/li&gt;
&lt;li&gt;RTC&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This makes the platform really flexible, and open to many usage scenarios.&lt;/p&gt;
&lt;h2&gt;What you can do with it&lt;/h2&gt;
&lt;p&gt;I developed few prototypes with Xadow, for example a small Twitter-enabled smartwatch, shown in the picture below. In this case the Xadow is controlling the display and communicating with an iOS app which is pulling Tweets from a twitter search or a specific account.&lt;/p&gt;
&lt;p&gt;&lt;img alt="The Tworologio Smartwatch concept" src="images/xadow-dashboard/tworologio.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;Many other makers are working with Xadow to build interesting wearable applications. For some examples check out &lt;a href="http://xadow.cc"&gt;http://xadow.cc&lt;/a&gt; where my concept is also showcased.&lt;/p&gt;
&lt;h2&gt;Creating Bluetooth smart apps with Xadow&lt;/h2&gt;
&lt;p&gt;Xadow is really useful when developing wearable connected accessories such as Smartwatches, jewels and similar objects. These are usually made by combining an Arduino-compatible app, running on the Xadow itself, possibly accessing data from some of the available sensors and interacting with the user with the display, and a smartphone or tablet app.&lt;/p&gt;
&lt;p&gt;With the advent of Bluetooth Low Energy, in fact, it is finally possible to develop iOS apps that talk to accessories, without getting a license from Apple. Also on Android, many newer phones and tablets got BLE support too.&lt;/p&gt;
&lt;p&gt;When developing such apps, especially when using the Bluetooth Low Energy mode, required for iOS compatibility, you often have to write code which passes commands and data over the Bluetooth link, interprets it and invokes corresponding routines.&lt;/p&gt;
&lt;p&gt;Using the BLE communication, there are few issues to be considered: the most important is that the BLE link is quite fragile, and limited to the exchange of very small bits of information, maximum 20 bytes at a time.&lt;/p&gt;
&lt;p&gt;For this reason it is difficult to use libraries such as the Arduino-provided Commander, because most of them require to send arbitrary length packets.&lt;/p&gt;
&lt;p&gt;The solution is to create a Firmata-like protocol, and add on top of it some buffering in order to be able to manage packages longer than 20 bytes.&lt;/p&gt;
&lt;h2&gt;Xadow Dashboard&lt;/h2&gt;
&lt;p&gt;Xadow Dashboard is built out of two main components:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Xadow Firmata: an adaptation of the Firmata protocol, using mainly the SYSEX instructions to access data from the specific Xadow modules. In particular this is able to access the Battery, Built-in LED, the OLED display and so on.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Xadow Firmata ObjC module: this is a small library that allows communicating with the Firmata running on the Xadow, and can be reused in custom applications.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Xadow Dashboard iOS app: this is an example of how an iOS app can interact with Xadow, and is meant to contain several examples for usage scenarios, but could also serve as a basis for a specific applicaton.  &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The Xadow Firmata provided with the current version of Xadow Dashboard supports just Display, Accelerometer, BLE and RTC but other modules will also be supported as soon as I get access to them.&lt;/p&gt;
&lt;h2&gt;Screenshots&lt;/h2&gt;
&lt;p&gt;The following few screens showcase the current implemented functionality:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Xadow Dashboard" src="images/xadow-dashboard/dashboard1.jpg" /&gt;
&lt;img alt="Xadow Dashboard" src="images/xadow-dashboard/dashboard2.jpg" /&gt;
&lt;img alt="Xadow Dashboard" src="images/xadow-dashboard/dashboard3.jpg" /&gt;&lt;/p&gt;
&lt;h2&gt;Source code&lt;/h2&gt;
&lt;p&gt;You can download the Xadow Dashboard project from my github account:&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/fibasile/XadowApps"&gt;https://github.com/fibasile/XadowApps&lt;/a&gt;&lt;/p&gt;</summary><category term="objc"></category><category term="firmata"></category><category term="xadow"></category><category term="ios"></category><category term="arduino"></category></entry><entry><title>Firmata-ObjC: controlling Arduino from ObjC Apps</title><link href="http://fibasile.github.io/firmata-objc-released.html" rel="alternate"></link><updated>2013-11-01T18:20:00+01:00</updated><author><name>Fiore Basile</name></author><id>tag:fibasile.github.io,2013-11-01:firmata-objc-released.html</id><summary type="html">&lt;p&gt;I'm releasing today a small wrapper framework and test program for Arduino Firmata protocol.&lt;/p&gt;
&lt;p&gt;The project is hosted on github: &lt;a href="http://github.com/fibasile/Firmata-ObjC"&gt;http://github.com/fibasile/Firmata-ObjC&lt;/a&gt; and released with the MIT License.&lt;/p&gt;
&lt;p&gt;Read on to learn more about it.&lt;/p&gt;
&lt;h2&gt;About firmata&lt;/h2&gt;
&lt;p&gt;The &lt;a href="http://firmata.org"&gt;firmata protocol&lt;/a&gt; was designed to allow programmers to control Arduino pins
from any programming language running on a host system.&lt;/p&gt;
&lt;p&gt;The latest 2.3 protocol version allows to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;discover pins available on the board&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;set pin modes to Analog, Input, Output, Servo and PWM&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;read input and output values&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The Firmata protocol supports most of the Arduino variants, and can be easily installed to the board as it's distributed with the standard Arduino IDE.&lt;/p&gt;
&lt;p&gt;To install it just fire the Arduino IDE and go to the File &amp;gt; Examples &amp;gt; Firmata &amp;gt; StandardFirmata menu&lt;/p&gt;
&lt;p&gt;&lt;img alt="Locating Firmata Sketch" src="images/firmata-objc/firmata1.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;And then upload the firmata sketch using the right arrow.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Uploading the Firmata Sketch" src="images/firmata-objc/firmata2.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;This basically provides a convenient way to write code for Arduino without ever changing the sketch uploaded to the board, and also to control your Arduino projects from your Mac.&lt;/p&gt;
&lt;h2&gt;Getting started&lt;/h2&gt;
&lt;p&gt;First of all you should download the framework and test project:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;clone&lt;/span&gt; &lt;span class="n"&gt;git&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="n"&gt;github&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;fibasile&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;Firmata&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;ObjC&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;git&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;And ORSSerialPort submodule:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="n"&gt;Firmata&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;Objc&lt;/span&gt;
&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;submodule&lt;/span&gt; &lt;span class="n"&gt;init&lt;/span&gt;
&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;submodule&lt;/span&gt; &lt;span class="n"&gt;update&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In the Mac/FirmataTestMac folder you will find the example project.&lt;/p&gt;
&lt;p&gt;In the Library folder you will find the actual library files. You can drop these into your project to use the Library.&lt;/p&gt;
&lt;p&gt;If you compile and run the FirmataTestMac you should get a window prompting for the serial connection parameters:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Connection options" src="images/firmata-objc/firmata3.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;Choose the serial port where Arduino is plugged in, and the Standard Firmata 57600 baud rate. Please note you need to plug it before running the project. Hit connect, and after few seconds you should get the following window:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Detail" src="images/firmata-objc/firmata4.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;This allows you to set the pin modes, change the values when Output mode is selected and so on.&lt;/p&gt;
&lt;p&gt;To test everything works, set the pin D13 to Output and hit the button several times. You should see the LED on your arduino board flashing.&lt;/p&gt;
&lt;p&gt;If it's not, check your serial port and baud rate settings (especially if other software is using it). Make sure you hit disconnect in the first window when you quit so you don't leave the serial port locked.&lt;/p&gt;
&lt;h2&gt;Using Firmata-ObjC in your project&lt;/h2&gt;
&lt;p&gt;Since you need to communicate with the board using a serial port, in the deps folder the ORSSerialPort framework allows to access the unix-like serial port of your Mac.&lt;/p&gt;
&lt;p&gt;This adds an additional dependency, you should include the &lt;code&gt;IOKit.framework&lt;/code&gt; into your project to make it work.&lt;/p&gt;
&lt;p&gt;Take a look at the test program to see an example.&lt;/p&gt;
&lt;p&gt;The framework is structured around the &lt;code&gt;ADArduino&lt;/code&gt; class, which needs a ADUnixSerialPort to be initialized, so you will write something like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;ADUnixSerialPort&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;port&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;ADUnixSerialPort&lt;/span&gt; &lt;span class="n"&gt;alloc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;initWithDevice&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt; &lt;span class="n"&gt;baudRate&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;baud&lt;/span&gt; &lt;span class="n"&gt;timeout&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="n"&gt;ADArduino&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;arduino&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;ADArduino&lt;/span&gt; &lt;span class="n"&gt;alloc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;initWithSerial&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;port&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The &lt;code&gt;ADArduino&lt;/code&gt; class needs to query the Firmata sketch on the board to know which pins are available, which protocol version is used and so on. This is done using a block based callback:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;__block&lt;/span&gt; &lt;span class="n"&gt;ADArduino&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;_warduino&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;arduino&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;arduino&lt;/span&gt; &lt;span class="n"&gt;connectWithBlock&lt;/span&gt;&lt;span class="o"&gt;:^&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;

       &lt;span class="n"&gt;NSLog&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;@&amp;quot;Arduino connected&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
       &lt;span class="n"&gt;NSLog&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;@&amp;quot;Arduino Firmata version %@ %@&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,[&lt;/span&gt;&lt;span class="n"&gt;_warduino&lt;/span&gt; &lt;span class="n"&gt;firmataVersion&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;_warduino&lt;/span&gt; &lt;span class="n"&gt;firmataVersionString&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;

       &lt;span class="n"&gt;NSLog&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;@&amp;quot;Analog pins %@&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_warduino&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;analogPins&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
       &lt;span class="n"&gt;NSLog&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;@&amp;quot;Digital pins %@&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_warduino&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;digitalPins&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

       &lt;span class="c1"&gt;// now you can update the gui and start sending messages&lt;/span&gt;
   &lt;span class="p"&gt;}];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;After this initialization is complete you can access the pins in the &lt;code&gt;analogPins&lt;/code&gt; and &lt;code&gt;digitalPins&lt;/code&gt; properties.
All pins are instances of the &lt;code&gt;ADArduinoPin&lt;/code&gt; class, which provides the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;number: the number of the pin (for the digital pins)&lt;/li&gt;
&lt;li&gt;isAnalogPin: true if it's one of the analog capable A0-Ax pins&lt;/li&gt;
&lt;li&gt;analog_channel: the pin number for analog pins&lt;/li&gt;
&lt;li&gt;mode: a numeric property to change the mode using the constants (MODE_INPUT, MODE_OUTPUT, etc)&lt;/li&gt;
&lt;li&gt;currentMode: a string description of the current pin mode&lt;/li&gt;
&lt;li&gt;availableModes: an array of strings describing the supported modes for the pin (Analog,Input,Output,Servo,PWM)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For example to set the D13 pin to Output and On one would do:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;ADArduinoPin&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pin&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;arduino&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;digitalPins&lt;/span&gt; &lt;span class="n"&gt;objectAtIndex&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;13&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="n"&gt;pin&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;mode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MODE_OUTPUT&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;pin&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;that's it!&lt;/p&gt;
&lt;p&gt;When finished with the Arduino board, in order to unlock the serial port, it's necessary to call:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;arduino&lt;/span&gt; &lt;span class="n"&gt;stopListening&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;The Firmata-ObjC Framework makes it finally easy to establish a communication between Arduino and the Mac apps.&lt;/p&gt;
&lt;p&gt;I plan to add support for other communication channels, namely Bluetooth Low Energy, Bluetooth 2.0, Wifi and Ethernet Shields.&lt;/p&gt;
&lt;p&gt;The first should be quite easy and will allow to port the framework to the iOS devices supporting BLE.&lt;/p&gt;
&lt;p&gt;Hope you find the framework useful for your projects. Open an issue on GitHub if you find any problems.&lt;/p&gt;</summary><category term="objc"></category><category term="firmata"></category><category term="arduino"></category></entry></feed>